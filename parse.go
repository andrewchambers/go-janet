package janet

type JanetParserStatus int

const (
	JANET_PARSE_ROOT = iota
	JANET_PARSE_ERROR
	JANET_PARSE_PENDING
	JANET_PARSE_DEAD
)

const (
	PFLAG_CONTAINER     = 0x100
	PFLAG_BUFFER        = 0x200
	PFLAG_PARENS        = 0x400
	PFLAG_SQRBRACKETS   = 0x800
	PFLAG_CURLYBRACKETS = 0x1000
	PFLAG_STRING        = 0x2000
	PFLAG_LONGSTRING    = 0x4000
	PFLAG_READERMAC     = 0x8000
	PFLAG_ATSYM         = 0x10000
	PFLAG_COMMENT       = 0x20000
	PFLAG_TOKEN         = 0x40000
)

type Parser struct {
	args     []Value
	states   []ParseState
	buf      []byte
	line     int
	column   int
	pending  int
	lookback byte
	flag     int
	err      string
}

type ParseState struct {
	counter  int
	argn     int
	flags    int
	line     int
	column   int
	consumer Consumer
}

type Consumer func(parser *Parser, state *ParseState, c byte) int

func isWhitespace(c byte) bool {
	return c == ' ' ||
		c == '\t' ||
		c == '\n' ||
		c == '\r' ||
		c == '\v' ||
		c == '\f' ||
		c == 0
}

/* Code generated by cjanet/tools/symcharsgen.c.
 * The table contains 256 bits, where each bit is 1
 * if the corresponding ascii code is a symbol char, and 0
 * if not. The upper characters are also considered symbol
 * chars and are then checked for utf-8 compliance. */
var symchars = [8]uint32{
	0x00000000, 0xf7ffec72, 0xc7ffffff, 0x07fffffe,
	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
}

/* Check if a character is a valid symbol character
 * symbol chars are A-Z, a-z, 0-9, or one of !$&*+-./:<=>@\^_~| */
func isSymbolChar(c byte) bool {
	return (symchars[c>>5] & (uint32(1) << (c & 0x1F))) != 0
}

func (parser *Parser) checkDead() {
	if parser.flag != 0 {
		JanetPanic("parser is dead, cannot consume")
	}
	if parser.err != "" {
		JanetPanic("parser has unchecked error, cannot consume")
	}
}

func (parser *Parser) Init() {
	parser.args = []Value{}
	parser.states = []ParseState{}
	parser.buf = []byte{}
	parser.err = ""
	parser.lookback = 0
	parser.line = 1
	parser.column = 0
	parser.pending = 0
	parser.flag = 0
	parser.pushState(root, PFLAG_CONTAINER)
}

func (parser *Parser) pushState(consumer Consumer, flags int) {
	state := ParseState{
		counter:  0,
		argn:     0,
		flags:    flags,
		consumer: consumer,
		line:     parser.line,
		column:   parser.column,
	}
	parser.states = append(parser.states, state)
}

func (p *Parser) popState(val Value) {
	for {
		top := p.states[len(p.states)-1]
		p.states = p.states[:len(p.states)-1]
		newtop := &p.states[len(p.states)-1]
		if (newtop.flags & PFLAG_CONTAINER) != 0 {
			switch val := val.(type) {
			case *Tuple:
				val.Line = top.line
				val.Column = top.column
			default:
			}
			newtop.argn += 1
			/* Keep track of number of values in the root state */
			if len(p.states) == 1 {
				p.pending += 1
			}
			p.pushArg(p, val)
			return
		} else if (newtop.flags & PFLAG_READERMAC) != 0 {
			which := "<unknown>"
			t := NewTuple(2)
			c := newtop.flags & 0xFF

			switch c {
			case '\'':
				which = "quote"
			case ',':
				which = "unquote"
			case ';':
				which = "splice"
			case '|':
				which = "short-fn"
			case '~':
				which = "quasiquote"
			default:
			}
			t.Vals = append(t.Vals, Symbol(which))
			t.Vals = append(t.Vals, val)
			/* Quote source mapping info */
			t.Line = newtop.line
			t.Column = newtop.column
			val = t
		} else {
			return
		}
	}
}

func (parser *Parser) Consume(c byte) {
	consumed := 0
	parser.checkDead()
	if c == '\r' {
		parser.line += 1
		parser.column = 0
	} else if c == '\n' {
		parser.column = 0
		if parser.lookback != '\r' {
			parser.line += 1
		}
	} else {
		parser.column += 1
	}

	for consumed == 0 && parser.err == "" {
		state := &parser.states[len(parser.states)-1]
		consumed = state.consumer(parser, state, c)
	}

	parser.lookback = c
}

func root(p *Parser, state *ParseState, c byte) int {
	switch c {
	default:
		if isWhitespace(c) {
			return 1
		}
		if !isSymbolChar(c) {
			p.err = "unexpected character"
			return 1
		}
		p.pushState(tokenchar, PFLAG_TOKEN)
		return 0
	case '\'':
	case ',':
	case ';':
	case '~':
	case '|':
		p.pushState(root, PFLAG_READERMAC|int(c))
		return 1
	case '"':
		p.pushState(stringchar, PFLAG_STRING)
		return 1
	case '#':
		p.pushState(comment, PFLAG_COMMENT)
		return 1
	case '@':
		p.pushState(atsign, PFLAG_ATSYM)
		return 1
	case '`':
		p.pushState(longstring, PFLAG_LONGSTRING)
		return 1
	case ')':
	case ']':
	case '}':
		{
			var ds Value
			if len(p.states) == 1 {
				p.err = "unexpected delimiter"
				return 1
			}
			if (c == ')' && (state.flags&PFLAG_PARENS) != 0) ||
				(c == ']' && (state.flags&PFLAG_SQRBRACKETS) != 0) {
				if (state.flags & PFLAG_ATSYM) != 0 {
					ds = p.closeArray(p, state)
				} else {
					tupFlags := 0
					if c == ']' {
						tupFlags = JANET_TUPLE_FLAG_BRACKETCTOR
					}
					ds = p.closeTuple(state, tupFlags)
				}
			} else if c == '}' && ((state.flags & PFLAG_CURLYBRACKETS) != 0) {
				if (state.argn % 2) == 1 {
					p.err = "struct and table literals expect even number of arguments"
					return 1
				}
				if (state.flags & PFLAG_ATSYM) != 0 {
					ds = p.closeTable(p, state)
				} else {
					ds = p.closeStruct(p, state)
				}
			} else {
				p.err = "mismatched delimiter"
				return 1
			}
			p.popState(ds)
		}
		return 1
	case '(':
		p.pushState(root, PFLAG_CONTAINER|PFLAG_PARENS)
		return 1
	case '[':
		p.pushState(root, PFLAG_CONTAINER|PFLAG_SQRBRACKETS)
		return 1
	case '{':
		p.pushState(root, PFLAG_CONTAINER|PFLAG_CURLYBRACKETS)
		return 1
	}
	panic("unreachable")
}

func tokenchar(p *Parser, state *ParseState, c byte) int {
	panic("XXX")
}

func stringchar(p *Parser, state *ParseState, c byte) int {
	panic("XXX")
}

func comment(p *Parser, state *ParseState, c byte) int {
	panic("XXX")
}

func atsign(p *Parser, state *ParseState, c byte) int {
	panic("XXX")
}

func longstring(p *Parser, state *ParseState, c byte) int {
	panic("XXX")
}
